# Receiver

This document address the design of the `cvmfs_receiver`.

## Context

The receiver is the terminal piece in the gateway infrastructure. The receiver
purpose is to push into stable storage the object pack generated by the
publisher.

From an high-level view, the publisher, coordinated by the `cvmfs_gateway`,
does the computation heavy lifting part of ingesting files in CVMFS. The
publisher hashs files and prepare them for ingestion.  The publisher packs the
result of its work in a structure called `ObjectPack` (in `cvmfs/pack.h`).

The `ObjectPack`s are then send over to the `cvmfs_gateway` which hands them
over to the `cvmfs_receiver`.

The `cvmfs_receive` get all those ObjectPack and push them into stable storage.

## Design

The receiver is a long living process, it listen for events from a file
descriptor and act on those events replying on another file descriptor.
Generally the file descriptor will be stdin and stdout.

The main of `cvmfs_receiver` is in `cvmfs/receiver/receiver.cc`, there is a
little of boilerplate and eventually it offload all the work to the reactor.

The reactor simply reads stdin, parse the requests and the data (which are
stored in different variables) and acts on them using handles.

We will focus on two of those handles:
1. `HandleSubmitPayload`
2. `HandleCommit`

There are other few handles that we will skip over in this document:
3. `HandleGenerateToken`
4. `HandleGetTokenId`
5. `HandleCheckToken`

### HandleSubmitPayload

This handle starts by reading a JSON from the data of the request and then pass
the heavy lifting to the `PayloadProcessor`.

With a layer of indirection passing by `ObjectPackConsumer` which is a
`Observable<ObjectPackBuild::Event>`, eventually we call
`PayloadProcessor::ConsumerEventCallback` for each `ObjectPackBuild::Event`.

The `ConsumerEventCallback` checks if the file is already on storage using the
`spooler_->Peek` function and, if not, upload it using `spooler_->Upload`.

Note that `Observable` is defined in `cvmfs/cvmfs/util_concurrency_impl.h`.

### HandleCommit

This handle works similarly to the previous one. Most of the work is done by
the `CommitProcessor`.

Eventually most of the work is done by the `CatalogMergeTool` which in turns
outsource it to the `CatalogDiffTool`
